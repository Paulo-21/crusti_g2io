use super::{BoxedGenerator, GeneratorFactory};
use crate::{
    core::parameters::{ParameterParser, ParameterType},
    Graph, NamedParam,
};
use anyhow::{Context, Result};
use petgraph::EdgeType;
use rand::Rng;

/// A factory used to build generators for chain graphs.
///
/// In directed graphs generated by this objects, edges go from nodes to the ones with the same index plus one.
///
/// Such factories can be created by passing `chain/n` to [`generators::generator_factory_from_str`](crate::generators#generator_factory_from_str),
/// where `n` is the size of chain to produce and must at least 0.
#[derive(Default)]
pub struct ChainGeneratorFactory;

impl<Ty, R> NamedParam<BoxedGenerator<Ty, R>> for ChainGeneratorFactory
where
    Ty: EdgeType,
{
    fn name(&self) -> &'static str {
        "chain"
    }

    fn description(&self) -> Vec<&'static str> {
        vec![
            "A generator producing a chain of nodes.",
            "The first parameter gives the length of the chain.",
        ]
    }

    fn try_with_params(&self, params: &str) -> Result<BoxedGenerator<Ty, R>> {
        let context = "while building a chain generator";
        let parameter_parser = ParameterParser::new(vec![ParameterType::PositiveInteger]);
        let parameter_values = parameter_parser.parse(params).context(context)?;
        let n = parameter_values[0].unwrap_usize();
        Ok(Box::new(move |_| match n {
            0 => Graph::default(),
            1 => {
                let mut g = Graph::with_capacity(1, 0);
                g.new_node();
                g
            }
            _ => {
                let mut g = Graph::with_capacity(n, n - 1);
                (0..n - 1).for_each(|i| g.new_edge(i, i + 1));
                g
            }
        }))
    }
}

impl<Ty, R> GeneratorFactory<Ty, R> for ChainGeneratorFactory
where
    R: Rng,
    Ty: EdgeType,
{
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::NodeIndexType;
    use petgraph::Directed;
    use rand::rngs::ThreadRng;

    #[test]
    fn test_not_enough_params() {
        assert!((ChainGeneratorFactory.try_with_params("")
            as Result<BoxedGenerator<Directed, ThreadRng>>)
            .is_err())
    }

    #[test]
    fn test_too_much_params() {
        assert!((ChainGeneratorFactory.try_with_params("1,1")
            as Result<BoxedGenerator<Directed, ThreadRng>>)
            .is_err())
    }

    #[test]
    fn test_chain_of_zero() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = ChainGeneratorFactory.try_with_params("0").unwrap()(&mut rng);
        assert_eq!(0, g.n_nodes());
        assert_eq!(0, g.n_edges());
    }

    #[test]
    fn test_chain_of_one() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = ChainGeneratorFactory.try_with_params("1").unwrap()(&mut rng);
        assert_eq!(1, g.n_nodes());
        assert_eq!(0, g.n_edges());
    }

    #[test]
    fn test_chain() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = ChainGeneratorFactory.try_with_params("3").unwrap()(&mut rng);
        assert_eq!(3, g.n_nodes());
        assert_eq!(
            vec![(0, 1), (1, 2)],
            g.iter_edges()
                .collect::<Vec<(NodeIndexType, NodeIndexType)>>()
        );
    }
}
