use super::{BoxedGenerator, GeneratorFactory};
use crate::{Graph, NamedParam, ParameterType, ParameterValue};
use anyhow::Result;
use petgraph::EdgeType;
use rand::Rng;

/// A factory used to build generators for path graphs.
///
/// In directed graphs generated by this objects, edges go from nodes to the ones with the same index plus one.
///
/// Such factories can be created by passing `path/n` to [`generators::generator_factory_from_str`](crate::generators#generator_factory_from_str),
/// where `n` is the length of path to produce and must at least 0.
#[derive(Default)]
pub struct PathGeneratorFactory;

impl<Ty, R> NamedParam<BoxedGenerator<Ty, R>> for PathGeneratorFactory
where
    Ty: EdgeType,
{
    fn name(&self) -> &'static str {
        "path"
    }

    fn description(&self) -> Vec<&'static str> {
        vec![
            "A generator producing a path graph.",
            "The first parameter gives the length of the path.",
        ]
    }

    fn expected_parameter_types(&self) -> Vec<ParameterType> {
        vec![ParameterType::PositiveInteger]
    }

    fn try_with_params(
        &self,
        parameter_values: Vec<ParameterValue>,
    ) -> Result<BoxedGenerator<Ty, R>> {
        let n = parameter_values[0].unwrap_usize();
        Ok(Box::new(move |_| match n {
            0 => Graph::default(),
            1 => {
                let mut g = Graph::with_capacity(1, 0);
                g.new_node();
                g
            }
            _ => {
                let mut g = Graph::with_capacity(n, n - 1);
                (0..n - 1).for_each(|i| g.new_edge(i, i + 1));
                g
            }
        }))
    }
}

impl<Ty, R> GeneratorFactory<Ty, R> for PathGeneratorFactory
where
    R: Rng,
    Ty: EdgeType,
{
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::NodeIndexType;
    use petgraph::Directed;

    #[test]
    fn test_path_of_zero() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = PathGeneratorFactory
            .try_with_params(vec![ParameterValue::PositiveInteger(0)])
            .unwrap()(&mut rng);
        assert_eq!(0, g.n_nodes());
        assert_eq!(0, g.n_edges());
    }

    #[test]
    fn test_path_of_one() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = PathGeneratorFactory
            .try_with_params(vec![ParameterValue::PositiveInteger(1)])
            .unwrap()(&mut rng);
        assert_eq!(1, g.n_nodes());
        assert_eq!(0, g.n_edges());
    }

    #[test]
    fn test_path() {
        let mut rng = rand::thread_rng();
        let g: Graph<Directed> = PathGeneratorFactory
            .try_with_params(vec![ParameterValue::PositiveInteger(3)])
            .unwrap()(&mut rng);
        assert_eq!(3, g.n_nodes());
        assert_eq!(
            vec![(0, 1), (1, 2)],
            g.iter_edges()
                .collect::<Vec<(NodeIndexType, NodeIndexType)>>()
        );
    }
}
